// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: account_credentials_keys.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const countAccountCredentialKeysByAccountCredentialID = `-- name: CountAccountCredentialKeysByAccountCredentialID :one
SELECT COUNT(*) FROM "credentials_keys" "ckr"
LEFT JOIN "account_credentials_keys" "ack" ON "ack"."credentials_key_id" = "ckr"."id"
WHERE "ack"."account_credentials_id" = $1
LIMIT 1
`

func (q *Queries) CountAccountCredentialKeysByAccountCredentialID(ctx context.Context, accountCredentialsID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countAccountCredentialKeysByAccountCredentialID, accountCredentialsID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAccountCredentialKey = `-- name: CreateAccountCredentialKey :exec

INSERT INTO "account_credentials_keys" (
    "account_credentials_id",
    "credentials_key_id",
    "account_id",
    "account_public_id",
    "jwk_kid"
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
`

type CreateAccountCredentialKeyParams struct {
	AccountCredentialsID int32
	CredentialsKeyID     int32
	AccountID            int32
	AccountPublicID      uuid.UUID
	JwkKid               string
}

// Copyright (c) 2025 Afonso Barracha
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
func (q *Queries) CreateAccountCredentialKey(ctx context.Context, arg CreateAccountCredentialKeyParams) error {
	_, err := q.db.Exec(ctx, createAccountCredentialKey,
		arg.AccountCredentialsID,
		arg.CredentialsKeyID,
		arg.AccountID,
		arg.AccountPublicID,
		arg.JwkKid,
	)
	return err
}

const findAccountCredentialKeyByAccountCredentialIDAndPublicKID = `-- name: FindAccountCredentialKeyByAccountCredentialIDAndPublicKID :one
SELECT ckr.id, ckr.public_kid, ckr.public_key, ckr.crypto_suite, ckr.is_revoked, ckr.usage, ckr.account_id, ckr.expires_at, ckr.created_at, ckr.updated_at FROM "credentials_keys" "ckr"
LEFT JOIN "account_credentials_keys" "ack" ON "ack"."credentials_key_id" = "ckr"."id"
WHERE 
    "ack"."account_credentials_id" = $1 AND 
    "ckr"."public_kid" = $2
LIMIT 1
`

type FindAccountCredentialKeyByAccountCredentialIDAndPublicKIDParams struct {
	AccountCredentialsID int32
	PublicKid            string
}

func (q *Queries) FindAccountCredentialKeyByAccountCredentialIDAndPublicKID(ctx context.Context, arg FindAccountCredentialKeyByAccountCredentialIDAndPublicKIDParams) (CredentialsKey, error) {
	row := q.db.QueryRow(ctx, findAccountCredentialKeyByAccountCredentialIDAndPublicKID, arg.AccountCredentialsID, arg.PublicKid)
	var i CredentialsKey
	err := row.Scan(
		&i.ID,
		&i.PublicKid,
		&i.PublicKey,
		&i.CryptoSuite,
		&i.IsRevoked,
		&i.Usage,
		&i.AccountID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findAccountCredentialsKeyAccountByAccountCredentialIDAndJWKKID = `-- name: FindAccountCredentialsKeyAccountByAccountCredentialIDAndJWKKID :one
SELECT a.id, a.public_id, a.given_name, a.family_name, a.username, a.email, a.organization, a.password, a.version, a.email_verified, a.is_active, a.two_factor_type, a.created_at, a.updated_at FROM "accounts" AS "a"
LEFT JOIN "account_credentials_keys" AS "ack" ON "ack"."account_id" = "a"."id"
WHERE
    "ack"."account_credentials_id" = $1 AND
    "ack"."jwk_kid" = $2
LIMIT 1
`

type FindAccountCredentialsKeyAccountByAccountCredentialIDAndJWKKIDParams struct {
	AccountCredentialsID int32
	JwkKid               string
}

func (q *Queries) FindAccountCredentialsKeyAccountByAccountCredentialIDAndJWKKID(ctx context.Context, arg FindAccountCredentialsKeyAccountByAccountCredentialIDAndJWKKIDParams) (Account, error) {
	row := q.db.QueryRow(ctx, findAccountCredentialsKeyAccountByAccountCredentialIDAndJWKKID, arg.AccountCredentialsID, arg.JwkKid)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.GivenName,
		&i.FamilyName,
		&i.Username,
		&i.Email,
		&i.Organization,
		&i.Password,
		&i.Version,
		&i.EmailVerified,
		&i.IsActive,
		&i.TwoFactorType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findActiveAccountCredentialKeysByAccountPublicID = `-- name: FindActiveAccountCredentialKeysByAccountPublicID :many
SELECT ckr.id, ckr.public_kid, ckr.public_key, ckr.crypto_suite, ckr.is_revoked, ckr.usage, ckr.account_id, ckr.expires_at, ckr.created_at, ckr.updated_at FROM "credentials_keys" "ckr"
LEFT JOIN "account_credentials_keys" "ack" ON "ack"."credentials_key_id" = "ckr"."id"
WHERE 
    "ack"."account_public_id" = $1 AND 
    "ckr"."is_revoked" = false AND 
    "ckr"."expires_at" > now()
ORDER BY "ckr"."expires_at" DESC
`

func (q *Queries) FindActiveAccountCredentialKeysByAccountPublicID(ctx context.Context, accountPublicID uuid.UUID) ([]CredentialsKey, error) {
	rows, err := q.db.Query(ctx, findActiveAccountCredentialKeysByAccountPublicID, accountPublicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CredentialsKey{}
	for rows.Next() {
		var i CredentialsKey
		if err := rows.Scan(
			&i.ID,
			&i.PublicKid,
			&i.PublicKey,
			&i.CryptoSuite,
			&i.IsRevoked,
			&i.Usage,
			&i.AccountID,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findCurrentAccountCredentialKeyByAccountCredentialID = `-- name: FindCurrentAccountCredentialKeyByAccountCredentialID :one
SELECT ckr.id, ckr.public_kid, ckr.public_key, ckr.crypto_suite, ckr.is_revoked, ckr.usage, ckr.account_id, ckr.expires_at, ckr.created_at, ckr.updated_at FROM "credentials_keys" "ckr"
LEFT JOIN "account_credentials_keys" "ack" ON "ack"."credentials_key_id" = "ckr"."id"
WHERE 
    "ack"."account_credentials_id" = $1 AND 
    "ckr"."is_revoked" = false AND 
    "ckr"."expires_at" > now()
LIMIT 1
`

func (q *Queries) FindCurrentAccountCredentialKeyByAccountCredentialID(ctx context.Context, accountCredentialsID int32) (CredentialsKey, error) {
	row := q.db.QueryRow(ctx, findCurrentAccountCredentialKeyByAccountCredentialID, accountCredentialsID)
	var i CredentialsKey
	err := row.Scan(
		&i.ID,
		&i.PublicKid,
		&i.PublicKey,
		&i.CryptoSuite,
		&i.IsRevoked,
		&i.Usage,
		&i.AccountID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findPaginatedAccountCredentialKeysByAccountCredentialID = `-- name: FindPaginatedAccountCredentialKeysByAccountCredentialID :many
SELECT ckr.id, ckr.public_kid, ckr.public_key, ckr.crypto_suite, ckr.is_revoked, ckr.usage, ckr.account_id, ckr.expires_at, ckr.created_at, ckr.updated_at FROM "credentials_keys" "ckr"
LEFT JOIN "account_credentials_keys" "ack" ON "ack"."credentials_key_id" = "ckr"."id"
WHERE "ack"."account_credentials_id" = $1
ORDER BY "ckr"."expires_at" DESC
OFFSET $2 LIMIT $3
`

type FindPaginatedAccountCredentialKeysByAccountCredentialIDParams struct {
	AccountCredentialsID int32
	Offset               int32
	Limit                int32
}

func (q *Queries) FindPaginatedAccountCredentialKeysByAccountCredentialID(ctx context.Context, arg FindPaginatedAccountCredentialKeysByAccountCredentialIDParams) ([]CredentialsKey, error) {
	rows, err := q.db.Query(ctx, findPaginatedAccountCredentialKeysByAccountCredentialID, arg.AccountCredentialsID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CredentialsKey{}
	for rows.Next() {
		var i CredentialsKey
		if err := rows.Scan(
			&i.ID,
			&i.PublicKid,
			&i.PublicKey,
			&i.CryptoSuite,
			&i.IsRevoked,
			&i.Usage,
			&i.AccountID,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
