// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: account_token_signing_keys.sql

package database

import (
	"context"
)

const createAccountTokenSigningKey = `-- name: CreateAccountTokenSigningKey :exec

INSERT INTO "account_token_signing_keys" (
    "account_id",
    "token_signing_key_id"
) VALUES (
    $1,
    $2
)
`

type CreateAccountTokenSigningKeyParams struct {
	AccountID         int32
	TokenSigningKeyID int32
}

// Copyright (c) 2025 Afonso Barracha
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
func (q *Queries) CreateAccountTokenSigningKey(ctx context.Context, arg CreateAccountTokenSigningKeyParams) error {
	_, err := q.db.Exec(ctx, createAccountTokenSigningKey, arg.AccountID, arg.TokenSigningKeyID)
	return err
}

const findAccountDistributedTokenSigningKeyPublicKeysByAccountID = `-- name: FindAccountDistributedTokenSigningKeyPublicKeysByAccountID :many
SELECT "t"."public_key" FROM "token_signing_keys" AS "t"
LEFT JOIN "account_token_signing_keys" AS "atsk" ON "t"."id" = "atsk"."token_signing_key_id"
WHERE "atsk"."account_id" = $1 AND
      "t"."is_distributed" = true AND
      "t"."is_revoked" = false AND
      "t"."expires_at" > NOW()
ORDER BY "t"."id" DESC
`

func (q *Queries) FindAccountDistributedTokenSigningKeyPublicKeysByAccountID(ctx context.Context, accountID int32) ([][]byte, error) {
	rows, err := q.db.Query(ctx, findAccountDistributedTokenSigningKeyPublicKeysByAccountID, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := [][]byte{}
	for rows.Next() {
		var public_key []byte
		if err := rows.Scan(&public_key); err != nil {
			return nil, err
		}
		items = append(items, public_key)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAccountTokenSigningKeyByAccountID = `-- name: FindAccountTokenSigningKeyByAccountID :one
SELECT t.id, t.kid, t.key_type, t.public_key, t.private_key, t.dek_kid, t.crypto_suite, t.expires_at, t.usage, t.is_distributed, t.is_revoked, t.created_at, t.updated_at FROM "token_signing_keys" AS "t"
LEFT JOIN "account_token_signing_keys" AS "atsk" ON "t"."id" = "atsk"."token_signing_key_id"
WHERE "atsk"."account_id" = $1 AND "t"."key_type" = $2
LIMIT 1
`

type FindAccountTokenSigningKeyByAccountIDParams struct {
	AccountID int32
	KeyType   TokenKeyType
}

func (q *Queries) FindAccountTokenSigningKeyByAccountID(ctx context.Context, arg FindAccountTokenSigningKeyByAccountIDParams) (TokenSigningKey, error) {
	row := q.db.QueryRow(ctx, findAccountTokenSigningKeyByAccountID, arg.AccountID, arg.KeyType)
	var i TokenSigningKey
	err := row.Scan(
		&i.ID,
		&i.Kid,
		&i.KeyType,
		&i.PublicKey,
		&i.PrivateKey,
		&i.DekKid,
		&i.CryptoSuite,
		&i.ExpiresAt,
		&i.Usage,
		&i.IsDistributed,
		&i.IsRevoked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findAccountTokenSigningKeyByAccountIDAndKID = `-- name: FindAccountTokenSigningKeyByAccountIDAndKID :one
SELECT t.id, t.kid, t.key_type, t.public_key, t.private_key, t.dek_kid, t.crypto_suite, t.expires_at, t.usage, t.is_distributed, t.is_revoked, t.created_at, t.updated_at FROM "token_signing_keys" AS "t"
LEFT JOIN "account_token_signing_keys" AS "atsk" ON "t"."id" = "atsk"."token_signing_key_id"
WHERE "atsk"."account_id" = $1 AND "t"."kid" = $2
LIMIT 1
`

type FindAccountTokenSigningKeyByAccountIDAndKIDParams struct {
	AccountID int32
	Kid       string
}

func (q *Queries) FindAccountTokenSigningKeyByAccountIDAndKID(ctx context.Context, arg FindAccountTokenSigningKeyByAccountIDAndKIDParams) (TokenSigningKey, error) {
	row := q.db.QueryRow(ctx, findAccountTokenSigningKeyByAccountIDAndKID, arg.AccountID, arg.Kid)
	var i TokenSigningKey
	err := row.Scan(
		&i.ID,
		&i.Kid,
		&i.KeyType,
		&i.PublicKey,
		&i.PrivateKey,
		&i.DekKid,
		&i.CryptoSuite,
		&i.ExpiresAt,
		&i.Usage,
		&i.IsDistributed,
		&i.IsRevoked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
