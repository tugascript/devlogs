// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: account_keys.sql

package database

import (
	"context"
	"time"
)

const createAccountKey = `-- name: CreateAccountKey :one
INSERT INTO "account_keys" (
    "oidc_config_id",
    "account_id",
    "name",
    "jwt_crypto_suite",
    "public_kid",
    "public_key",
    "private_key",
    "is_distributed",
    "expires_at"
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
) RETURNING id, account_id, oidc_config_id, name, jwt_crypto_suite, public_kid, public_key, private_key, is_distributed, expires_at, created_at, updated_at
`

type CreateAccountKeyParams struct {
	OidcConfigID   int32
	AccountID      int32
	Name           string
	JwtCryptoSuite string
	PublicKid      string
	PublicKey      []byte
	PrivateKey     string
	IsDistributed  bool
	ExpiresAt      time.Time
}

func (q *Queries) CreateAccountKey(ctx context.Context, arg CreateAccountKeyParams) (AccountKey, error) {
	row := q.db.QueryRow(ctx, createAccountKey,
		arg.OidcConfigID,
		arg.AccountID,
		arg.Name,
		arg.JwtCryptoSuite,
		arg.PublicKid,
		arg.PublicKey,
		arg.PrivateKey,
		arg.IsDistributed,
		arg.ExpiresAt,
	)
	var i AccountKey
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.OidcConfigID,
		&i.Name,
		&i.JwtCryptoSuite,
		&i.PublicKid,
		&i.PublicKey,
		&i.PrivateKey,
		&i.IsDistributed,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDistributedAccountKeysByAccountID = `-- name: DeleteDistributedAccountKeysByAccountID :exec

DELETE FROM "account_keys"
WHERE "account_id" = $1 AND "is_distributed" = true
`

// Copyright (c) 2025 Afonso Barracha
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
func (q *Queries) DeleteDistributedAccountKeysByAccountID(ctx context.Context, accountID int32) error {
	_, err := q.db.Exec(ctx, deleteDistributedAccountKeysByAccountID, accountID)
	return err
}

const findAccountKeyByAccountIDAndName = `-- name: FindAccountKeyByAccountIDAndName :one
SELECT id, account_id, oidc_config_id, name, jwt_crypto_suite, public_kid, public_key, private_key, is_distributed, expires_at, created_at, updated_at FROM "account_keys"
WHERE
    "account_id" = $1 AND
    "name" = $2 AND
    "expires_at" > $3
ORDER BY "id" DESC LIMIT 1
`

type FindAccountKeyByAccountIDAndNameParams struct {
	AccountID int32
	Name      string
	ExpiresAt time.Time
}

func (q *Queries) FindAccountKeyByAccountIDAndName(ctx context.Context, arg FindAccountKeyByAccountIDAndNameParams) (AccountKey, error) {
	row := q.db.QueryRow(ctx, findAccountKeyByAccountIDAndName, arg.AccountID, arg.Name, arg.ExpiresAt)
	var i AccountKey
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.OidcConfigID,
		&i.Name,
		&i.JwtCryptoSuite,
		&i.PublicKid,
		&i.PublicKey,
		&i.PrivateKey,
		&i.IsDistributed,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findAccountKeyByAccountIDAndNames = `-- name: FindAccountKeyByAccountIDAndNames :many
SELECT id, account_id, oidc_config_id, name, jwt_crypto_suite, public_kid, public_key, private_key, is_distributed, expires_at, created_at, updated_at FROM "account_keys"
WHERE
    "account_id" = $1 AND
    "name" = ANY($3) AND
    "expires_at" > $2
ORDER BY "id" DESC
`

type FindAccountKeyByAccountIDAndNamesParams struct {
	AccountID int32
	ExpiresAt time.Time
	Names     []string
}

func (q *Queries) FindAccountKeyByAccountIDAndNames(ctx context.Context, arg FindAccountKeyByAccountIDAndNamesParams) ([]AccountKey, error) {
	rows, err := q.db.Query(ctx, findAccountKeyByAccountIDAndNames, arg.AccountID, arg.ExpiresAt, arg.Names)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountKey{}
	for rows.Next() {
		var i AccountKey
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.OidcConfigID,
			&i.Name,
			&i.JwtCryptoSuite,
			&i.PublicKid,
			&i.PublicKey,
			&i.PrivateKey,
			&i.IsDistributed,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAccountKeyByPublicKID = `-- name: FindAccountKeyByPublicKID :one
SELECT id, account_id, oidc_config_id, name, jwt_crypto_suite, public_kid, public_key, private_key, is_distributed, expires_at, created_at, updated_at FROM "account_keys"
WHERE "public_kid" = $1
LIMIT 1
`

func (q *Queries) FindAccountKeyByPublicKID(ctx context.Context, publicKid string) (AccountKey, error) {
	row := q.db.QueryRow(ctx, findAccountKeyByPublicKID, publicKid)
	var i AccountKey
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.OidcConfigID,
		&i.Name,
		&i.JwtCryptoSuite,
		&i.PublicKid,
		&i.PublicKey,
		&i.PrivateKey,
		&i.IsDistributed,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findDistributedAccountKeysByAccountID = `-- name: FindDistributedAccountKeysByAccountID :many
SELECT id, account_id, oidc_config_id, name, jwt_crypto_suite, public_kid, public_key, private_key, is_distributed, expires_at, created_at, updated_at FROM "account_keys"
WHERE
    "account_id" = $1 AND
    "is_distributed" = true AND
    "expires_at" > NOW()
ORDER BY "id" DESC
`

func (q *Queries) FindDistributedAccountKeysByAccountID(ctx context.Context, accountID int32) ([]AccountKey, error) {
	rows, err := q.db.Query(ctx, findDistributedAccountKeysByAccountID, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountKey{}
	for rows.Next() {
		var i AccountKey
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.OidcConfigID,
			&i.Name,
			&i.JwtCryptoSuite,
			&i.PublicKid,
			&i.PublicKey,
			&i.PrivateKey,
			&i.IsDistributed,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
