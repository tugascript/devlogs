// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: account_dynamic_registration_domains.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const countAccountDynamicRegistrationDomainsByAccountPublicID = `-- name: CountAccountDynamicRegistrationDomainsByAccountPublicID :one
SELECT COUNT(*) FROM "account_dynamic_registration_domains"
WHERE "account_public_id" = $1
`

func (q *Queries) CountAccountDynamicRegistrationDomainsByAccountPublicID(ctx context.Context, accountPublicID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAccountDynamicRegistrationDomainsByAccountPublicID, accountPublicID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFilteredAccountDynamicRegistrationDomainsByAccountPublicID = `-- name: CountFilteredAccountDynamicRegistrationDomainsByAccountPublicID :one
SELECT COUNT(*) FROM "account_dynamic_registration_domains"
WHERE
    "account_public_id" = $1 AND
    "domain" ILIKE $2
LIMIT 1
`

type CountFilteredAccountDynamicRegistrationDomainsByAccountPublicIDParams struct {
	AccountPublicID uuid.UUID
	Domain          string
}

func (q *Queries) CountFilteredAccountDynamicRegistrationDomainsByAccountPublicID(ctx context.Context, arg CountFilteredAccountDynamicRegistrationDomainsByAccountPublicIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, countFilteredAccountDynamicRegistrationDomainsByAccountPublicID, arg.AccountPublicID, arg.Domain)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAccountDynamicRegistrationDomain = `-- name: CreateAccountDynamicRegistrationDomain :one

INSERT INTO "account_dynamic_registration_domains" (
    "account_id",
    "account_public_id",
    "domain",
    "verification_method"
) VALUES (
    $1,
    $2,
    $3,
    $4
) RETURNING id, account_id, account_public_id, domain, verified_at, verification_method, created_at, updated_at
`

type CreateAccountDynamicRegistrationDomainParams struct {
	AccountID          int32
	AccountPublicID    uuid.UUID
	Domain             string
	VerificationMethod DomainVerificationMethod
}

// Copyright (c) 2025 Afonso Barracha
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
func (q *Queries) CreateAccountDynamicRegistrationDomain(ctx context.Context, arg CreateAccountDynamicRegistrationDomainParams) (AccountDynamicRegistrationDomain, error) {
	row := q.db.QueryRow(ctx, createAccountDynamicRegistrationDomain,
		arg.AccountID,
		arg.AccountPublicID,
		arg.Domain,
		arg.VerificationMethod,
	)
	var i AccountDynamicRegistrationDomain
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.AccountPublicID,
		&i.Domain,
		&i.VerifiedAt,
		&i.VerificationMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAccountDynamicRegistrationDomain = `-- name: DeleteAccountDynamicRegistrationDomain :exec
DELETE FROM "account_dynamic_registration_domains"
WHERE "id" = $1
`

func (q *Queries) DeleteAccountDynamicRegistrationDomain(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteAccountDynamicRegistrationDomain, id)
	return err
}

const filterAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByDomain = `-- name: FilterAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByDomain :many
SELECT id, account_id, account_public_id, domain, verified_at, verification_method, created_at, updated_at FROM "account_dynamic_registration_domains"
WHERE
    "account_public_id" = $1 AND
    "domain" ILIKE $2
ORDER BY "domain" ASC
LIMIT $3 OFFSET $4
`

type FilterAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByDomainParams struct {
	AccountPublicID uuid.UUID
	Domain          string
	Limit           int32
	Offset          int32
}

func (q *Queries) FilterAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByDomain(ctx context.Context, arg FilterAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByDomainParams) ([]AccountDynamicRegistrationDomain, error) {
	rows, err := q.db.Query(ctx, filterAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByDomain,
		arg.AccountPublicID,
		arg.Domain,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountDynamicRegistrationDomain{}
	for rows.Next() {
		var i AccountDynamicRegistrationDomain
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.AccountPublicID,
			&i.Domain,
			&i.VerifiedAt,
			&i.VerificationMethod,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const filterAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByID = `-- name: FilterAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByID :many
SELECT id, account_id, account_public_id, domain, verified_at, verification_method, created_at, updated_at FROM "account_dynamic_registration_domains"
WHERE
    "account_public_id" = $1 AND
    "domain" ILIKE $2
ORDER BY "id" DESC
LIMIT $3 OFFSET $4
`

type FilterAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByIDParams struct {
	AccountPublicID uuid.UUID
	Domain          string
	Limit           int32
	Offset          int32
}

func (q *Queries) FilterAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByID(ctx context.Context, arg FilterAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByIDParams) ([]AccountDynamicRegistrationDomain, error) {
	rows, err := q.db.Query(ctx, filterAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByID,
		arg.AccountPublicID,
		arg.Domain,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountDynamicRegistrationDomain{}
	for rows.Next() {
		var i AccountDynamicRegistrationDomain
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.AccountPublicID,
			&i.Domain,
			&i.VerifiedAt,
			&i.VerificationMethod,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAccountDynamicRegistrationDomainByAccountPublicIDAndDomain = `-- name: FindAccountDynamicRegistrationDomainByAccountPublicIDAndDomain :one
SELECT id, account_id, account_public_id, domain, verified_at, verification_method, created_at, updated_at FROM "account_dynamic_registration_domains" WHERE "account_public_id" = $1 AND "domain" = $2 LIMIT 1
`

type FindAccountDynamicRegistrationDomainByAccountPublicIDAndDomainParams struct {
	AccountPublicID uuid.UUID
	Domain          string
}

func (q *Queries) FindAccountDynamicRegistrationDomainByAccountPublicIDAndDomain(ctx context.Context, arg FindAccountDynamicRegistrationDomainByAccountPublicIDAndDomainParams) (AccountDynamicRegistrationDomain, error) {
	row := q.db.QueryRow(ctx, findAccountDynamicRegistrationDomainByAccountPublicIDAndDomain, arg.AccountPublicID, arg.Domain)
	var i AccountDynamicRegistrationDomain
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.AccountPublicID,
		&i.Domain,
		&i.VerifiedAt,
		&i.VerificationMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findPaginatedAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByDomain = `-- name: FindPaginatedAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByDomain :many
SELECT id, account_id, account_public_id, domain, verified_at, verification_method, created_at, updated_at FROM "account_dynamic_registration_domains"
WHERE "account_public_id" = $1
ORDER BY "domain" ASC
LIMIT $2 OFFSET $3
`

type FindPaginatedAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByDomainParams struct {
	AccountPublicID uuid.UUID
	Limit           int32
	Offset          int32
}

func (q *Queries) FindPaginatedAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByDomain(ctx context.Context, arg FindPaginatedAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByDomainParams) ([]AccountDynamicRegistrationDomain, error) {
	rows, err := q.db.Query(ctx, findPaginatedAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByDomain, arg.AccountPublicID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountDynamicRegistrationDomain{}
	for rows.Next() {
		var i AccountDynamicRegistrationDomain
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.AccountPublicID,
			&i.Domain,
			&i.VerifiedAt,
			&i.VerificationMethod,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByID = `-- name: FindPaginatedAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByID :many
SELECT id, account_id, account_public_id, domain, verified_at, verification_method, created_at, updated_at FROM "account_dynamic_registration_domains"
WHERE "account_public_id" = $1
ORDER BY "id" DESC
LIMIT $2 OFFSET $3
`

type FindPaginatedAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByIDParams struct {
	AccountPublicID uuid.UUID
	Limit           int32
	Offset          int32
}

func (q *Queries) FindPaginatedAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByID(ctx context.Context, arg FindPaginatedAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByIDParams) ([]AccountDynamicRegistrationDomain, error) {
	rows, err := q.db.Query(ctx, findPaginatedAccountDynamicRegistrationDomainsByAccountPublicIDOrderedByID, arg.AccountPublicID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountDynamicRegistrationDomain{}
	for rows.Next() {
		var i AccountDynamicRegistrationDomain
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.AccountPublicID,
			&i.Domain,
			&i.VerifiedAt,
			&i.VerificationMethod,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const verifyAccountDynamicRegistrationDomain = `-- name: VerifyAccountDynamicRegistrationDomain :one
UPDATE "account_dynamic_registration_domains"
SET
    "verified_at" = NOW(),
    "verification_method" = $2
WHERE "id" = $1 RETURNING id, account_id, account_public_id, domain, verified_at, verification_method, created_at, updated_at
`

type VerifyAccountDynamicRegistrationDomainParams struct {
	ID                 int32
	VerificationMethod DomainVerificationMethod
}

func (q *Queries) VerifyAccountDynamicRegistrationDomain(ctx context.Context, arg VerifyAccountDynamicRegistrationDomainParams) (AccountDynamicRegistrationDomain, error) {
	row := q.db.QueryRow(ctx, verifyAccountDynamicRegistrationDomain, arg.ID, arg.VerificationMethod)
	var i AccountDynamicRegistrationDomain
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.AccountPublicID,
		&i.Domain,
		&i.VerifiedAt,
		&i.VerificationMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
