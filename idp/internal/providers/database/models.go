// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package database

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type AccountCredentialsScope string

const (
	AccountCredentialsScopeEmail                    AccountCredentialsScope = "email"
	AccountCredentialsScopeProfile                  AccountCredentialsScope = "profile"
	AccountCredentialsScopeAccountAdmin             AccountCredentialsScope = "account:admin"
	AccountCredentialsScopeAccountUsersRead         AccountCredentialsScope = "account:users:read"
	AccountCredentialsScopeAccountUsersWrite        AccountCredentialsScope = "account:users:write"
	AccountCredentialsScopeAccountAppsRead          AccountCredentialsScope = "account:apps:read"
	AccountCredentialsScopeAccountAppsWrite         AccountCredentialsScope = "account:apps:write"
	AccountCredentialsScopeAccountCredentialsRead   AccountCredentialsScope = "account:credentials:read"
	AccountCredentialsScopeAccountCredentialsWrite  AccountCredentialsScope = "account:credentials:write"
	AccountCredentialsScopeAccountAuthProvidersRead AccountCredentialsScope = "account:auth_providers:read"
)

func (e *AccountCredentialsScope) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccountCredentialsScope(s)
	case string:
		*e = AccountCredentialsScope(s)
	default:
		return fmt.Errorf("unsupported scan type for AccountCredentialsScope: %T", src)
	}
	return nil
}

type NullAccountCredentialsScope struct {
	AccountCredentialsScope AccountCredentialsScope
	Valid                   bool // Valid is true if AccountCredentialsScope is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccountCredentialsScope) Scan(value interface{}) error {
	if value == nil {
		ns.AccountCredentialsScope, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccountCredentialsScope.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccountCredentialsScope) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccountCredentialsScope), nil
}

type AccountCredentialsType string

const (
	AccountCredentialsTypeNative  AccountCredentialsType = "native"
	AccountCredentialsTypeService AccountCredentialsType = "service"
	AccountCredentialsTypeMcp     AccountCredentialsType = "mcp"
)

func (e *AccountCredentialsType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccountCredentialsType(s)
	case string:
		*e = AccountCredentialsType(s)
	default:
		return fmt.Errorf("unsupported scan type for AccountCredentialsType: %T", src)
	}
	return nil
}

type NullAccountCredentialsType struct {
	AccountCredentialsType AccountCredentialsType
	Valid                  bool // Valid is true if AccountCredentialsType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccountCredentialsType) Scan(value interface{}) error {
	if value == nil {
		ns.AccountCredentialsType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccountCredentialsType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccountCredentialsType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccountCredentialsType), nil
}

type AppProfileType string

const (
	AppProfileTypeHuman   AppProfileType = "human"
	AppProfileTypeMachine AppProfileType = "machine"
	AppProfileTypeAiAgent AppProfileType = "ai_agent"
)

func (e *AppProfileType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AppProfileType(s)
	case string:
		*e = AppProfileType(s)
	default:
		return fmt.Errorf("unsupported scan type for AppProfileType: %T", src)
	}
	return nil
}

type NullAppProfileType struct {
	AppProfileType AppProfileType
	Valid          bool // Valid is true if AppProfileType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAppProfileType) Scan(value interface{}) error {
	if value == nil {
		ns.AppProfileType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AppProfileType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAppProfileType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AppProfileType), nil
}

type AppType string

const (
	AppTypeWeb     AppType = "web"
	AppTypeNative  AppType = "native"
	AppTypeSpa     AppType = "spa"
	AppTypeBackend AppType = "backend"
	AppTypeDevice  AppType = "device"
	AppTypeService AppType = "service"
	AppTypeMcp     AppType = "mcp"
)

func (e *AppType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AppType(s)
	case string:
		*e = AppType(s)
	default:
		return fmt.Errorf("unsupported scan type for AppType: %T", src)
	}
	return nil
}

type NullAppType struct {
	AppType AppType
	Valid   bool // Valid is true if AppType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAppType) Scan(value interface{}) error {
	if value == nil {
		ns.AppType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AppType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAppType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AppType), nil
}

type AppUsernameColumn string

const (
	AppUsernameColumnEmail    AppUsernameColumn = "email"
	AppUsernameColumnUsername AppUsernameColumn = "username"
	AppUsernameColumnBoth     AppUsernameColumn = "both"
)

func (e *AppUsernameColumn) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AppUsernameColumn(s)
	case string:
		*e = AppUsernameColumn(s)
	default:
		return fmt.Errorf("unsupported scan type for AppUsernameColumn: %T", src)
	}
	return nil
}

type NullAppUsernameColumn struct {
	AppUsernameColumn AppUsernameColumn
	Valid             bool // Valid is true if AppUsernameColumn is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAppUsernameColumn) Scan(value interface{}) error {
	if value == nil {
		ns.AppUsernameColumn, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AppUsernameColumn.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAppUsernameColumn) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AppUsernameColumn), nil
}

type AuthMethod string

const (
	AuthMethodNone              AuthMethod = "none"
	AuthMethodClientSecretBasic AuthMethod = "client_secret_basic"
	AuthMethodClientSecretPost  AuthMethod = "client_secret_post"
	AuthMethodClientSecretJwt   AuthMethod = "client_secret_jwt"
	AuthMethodPrivateKeyJwt     AuthMethod = "private_key_jwt"
)

func (e *AuthMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuthMethod(s)
	case string:
		*e = AuthMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for AuthMethod: %T", src)
	}
	return nil
}

type NullAuthMethod struct {
	AuthMethod AuthMethod
	Valid      bool // Valid is true if AuthMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuthMethod) Scan(value interface{}) error {
	if value == nil {
		ns.AuthMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuthMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuthMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuthMethod), nil
}

type AuthProvider string

const (
	AuthProviderLocal     AuthProvider = "local"
	AuthProviderApple     AuthProvider = "apple"
	AuthProviderFacebook  AuthProvider = "facebook"
	AuthProviderGithub    AuthProvider = "github"
	AuthProviderGoogle    AuthProvider = "google"
	AuthProviderMicrosoft AuthProvider = "microsoft"
)

func (e *AuthProvider) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuthProvider(s)
	case string:
		*e = AuthProvider(s)
	default:
		return fmt.Errorf("unsupported scan type for AuthProvider: %T", src)
	}
	return nil
}

type NullAuthProvider struct {
	AuthProvider AuthProvider
	Valid        bool // Valid is true if AuthProvider is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuthProvider) Scan(value interface{}) error {
	if value == nil {
		ns.AuthProvider, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuthProvider.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuthProvider) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuthProvider), nil
}

type Claims string

const (
	ClaimsSub                 Claims = "sub"
	ClaimsName                Claims = "name"
	ClaimsGivenName           Claims = "given_name"
	ClaimsFamilyName          Claims = "family_name"
	ClaimsMiddleName          Claims = "middle_name"
	ClaimsNickname            Claims = "nickname"
	ClaimsPreferredUsername   Claims = "preferred_username"
	ClaimsProfile             Claims = "profile"
	ClaimsPicture             Claims = "picture"
	ClaimsWebsite             Claims = "website"
	ClaimsEmail               Claims = "email"
	ClaimsEmailVerified       Claims = "email_verified"
	ClaimsGender              Claims = "gender"
	ClaimsBirthdate           Claims = "birthdate"
	ClaimsZoneinfo            Claims = "zoneinfo"
	ClaimsLocale              Claims = "locale"
	ClaimsPhoneNumber         Claims = "phone_number"
	ClaimsPhoneNumberVerified Claims = "phone_number_verified"
	ClaimsAddress             Claims = "address"
	ClaimsUpdatedAt           Claims = "updated_at"
)

func (e *Claims) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Claims(s)
	case string:
		*e = Claims(s)
	default:
		return fmt.Errorf("unsupported scan type for Claims: %T", src)
	}
	return nil
}

type NullClaims struct {
	Claims Claims
	Valid  bool // Valid is true if Claims is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullClaims) Scan(value interface{}) error {
	if value == nil {
		ns.Claims, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Claims.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullClaims) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Claims), nil
}

type CreationMethod string

const (
	CreationMethodManual              CreationMethod = "manual"
	CreationMethodDynamicRegistration CreationMethod = "dynamic_registration"
)

func (e *CreationMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CreationMethod(s)
	case string:
		*e = CreationMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for CreationMethod: %T", src)
	}
	return nil
}

type NullCreationMethod struct {
	CreationMethod CreationMethod
	Valid          bool // Valid is true if CreationMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCreationMethod) Scan(value interface{}) error {
	if value == nil {
		ns.CreationMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CreationMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCreationMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CreationMethod), nil
}

type CredentialsUsage string

const (
	CredentialsUsageAccount CredentialsUsage = "account"
	CredentialsUsageApp     CredentialsUsage = "app"
	CredentialsUsageUser    CredentialsUsage = "user"
)

func (e *CredentialsUsage) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CredentialsUsage(s)
	case string:
		*e = CredentialsUsage(s)
	default:
		return fmt.Errorf("unsupported scan type for CredentialsUsage: %T", src)
	}
	return nil
}

type NullCredentialsUsage struct {
	CredentialsUsage CredentialsUsage
	Valid            bool // Valid is true if CredentialsUsage is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCredentialsUsage) Scan(value interface{}) error {
	if value == nil {
		ns.CredentialsUsage, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CredentialsUsage.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCredentialsUsage) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CredentialsUsage), nil
}

type DekUsage string

const (
	DekUsageGlobal  DekUsage = "global"
	DekUsageAccount DekUsage = "account"
	DekUsageUser    DekUsage = "user"
)

func (e *DekUsage) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DekUsage(s)
	case string:
		*e = DekUsage(s)
	default:
		return fmt.Errorf("unsupported scan type for DekUsage: %T", src)
	}
	return nil
}

type NullDekUsage struct {
	DekUsage DekUsage
	Valid    bool // Valid is true if DekUsage is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDekUsage) Scan(value interface{}) error {
	if value == nil {
		ns.DekUsage, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DekUsage.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDekUsage) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DekUsage), nil
}

type DomainVerificationMethod string

const (
	DomainVerificationMethodAuthorizationCode DomainVerificationMethod = "authorization_code"
	DomainVerificationMethodSoftwareStatement DomainVerificationMethod = "software_statement"
	DomainVerificationMethodDnsTxtRecord      DomainVerificationMethod = "dns_txt_record"
)

func (e *DomainVerificationMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DomainVerificationMethod(s)
	case string:
		*e = DomainVerificationMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for DomainVerificationMethod: %T", src)
	}
	return nil
}

type NullDomainVerificationMethod struct {
	DomainVerificationMethod DomainVerificationMethod
	Valid                    bool // Valid is true if DomainVerificationMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDomainVerificationMethod) Scan(value interface{}) error {
	if value == nil {
		ns.DomainVerificationMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DomainVerificationMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDomainVerificationMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DomainVerificationMethod), nil
}

type GrantType string

const (
	GrantTypeAuthorizationCode                     GrantType = "authorization_code"
	GrantTypeRefreshToken                          GrantType = "refresh_token"
	GrantTypeClientCredentials                     GrantType = "client_credentials"
	GrantTypeUrnIetfParamsOauthGrantTypeDeviceCode GrantType = "urn:ietf:params:oauth:grant-type:device_code"
	GrantTypeUrnIetfParamsOauthGrantTypeJwtBearer  GrantType = "urn:ietf:params:oauth:grant-type:jwt-bearer"
)

func (e *GrantType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GrantType(s)
	case string:
		*e = GrantType(s)
	default:
		return fmt.Errorf("unsupported scan type for GrantType: %T", src)
	}
	return nil
}

type NullGrantType struct {
	GrantType GrantType
	Valid     bool // Valid is true if GrantType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGrantType) Scan(value interface{}) error {
	if value == nil {
		ns.GrantType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GrantType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGrantType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GrantType), nil
}

type InitialAccessTokenGenerationMethod string

const (
	InitialAccessTokenGenerationMethodManual            InitialAccessTokenGenerationMethod = "manual"
	InitialAccessTokenGenerationMethodAuthorizationCode InitialAccessTokenGenerationMethod = "authorization_code"
)

func (e *InitialAccessTokenGenerationMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InitialAccessTokenGenerationMethod(s)
	case string:
		*e = InitialAccessTokenGenerationMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for InitialAccessTokenGenerationMethod: %T", src)
	}
	return nil
}

type NullInitialAccessTokenGenerationMethod struct {
	InitialAccessTokenGenerationMethod InitialAccessTokenGenerationMethod
	Valid                              bool // Valid is true if InitialAccessTokenGenerationMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInitialAccessTokenGenerationMethod) Scan(value interface{}) error {
	if value == nil {
		ns.InitialAccessTokenGenerationMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InitialAccessTokenGenerationMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInitialAccessTokenGenerationMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InitialAccessTokenGenerationMethod), nil
}

type KekUsage string

const (
	KekUsageGlobal  KekUsage = "global"
	KekUsageAccount KekUsage = "account"
)

func (e *KekUsage) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = KekUsage(s)
	case string:
		*e = KekUsage(s)
	default:
		return fmt.Errorf("unsupported scan type for KekUsage: %T", src)
	}
	return nil
}

type NullKekUsage struct {
	KekUsage KekUsage
	Valid    bool // Valid is true if KekUsage is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullKekUsage) Scan(value interface{}) error {
	if value == nil {
		ns.KekUsage, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.KekUsage.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullKekUsage) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.KekUsage), nil
}

type ResponseType string

const (
	ResponseTypeCode        ResponseType = "code"
	ResponseTypeIDToken     ResponseType = "id_token"
	ResponseTypeCodeidToken ResponseType = "code id_token"
)

func (e *ResponseType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ResponseType(s)
	case string:
		*e = ResponseType(s)
	default:
		return fmt.Errorf("unsupported scan type for ResponseType: %T", src)
	}
	return nil
}

type NullResponseType struct {
	ResponseType ResponseType
	Valid        bool // Valid is true if ResponseType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullResponseType) Scan(value interface{}) error {
	if value == nil {
		ns.ResponseType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ResponseType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullResponseType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ResponseType), nil
}

type Scopes string

const (
	ScopesOpenid  Scopes = "openid"
	ScopesEmail   Scopes = "email"
	ScopesProfile Scopes = "profile"
	ScopesAddress Scopes = "address"
	ScopesPhone   Scopes = "phone"
)

func (e *Scopes) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Scopes(s)
	case string:
		*e = Scopes(s)
	default:
		return fmt.Errorf("unsupported scan type for Scopes: %T", src)
	}
	return nil
}

type NullScopes struct {
	Scopes Scopes
	Valid  bool // Valid is true if Scopes is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullScopes) Scan(value interface{}) error {
	if value == nil {
		ns.Scopes, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Scopes.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullScopes) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Scopes), nil
}

type SecretStorageMode string

const (
	SecretStorageModeHashed    SecretStorageMode = "hashed"
	SecretStorageModeEncrypted SecretStorageMode = "encrypted"
)

func (e *SecretStorageMode) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SecretStorageMode(s)
	case string:
		*e = SecretStorageMode(s)
	default:
		return fmt.Errorf("unsupported scan type for SecretStorageMode: %T", src)
	}
	return nil
}

type NullSecretStorageMode struct {
	SecretStorageMode SecretStorageMode
	Valid             bool // Valid is true if SecretStorageMode is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSecretStorageMode) Scan(value interface{}) error {
	if value == nil {
		ns.SecretStorageMode, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SecretStorageMode.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSecretStorageMode) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SecretStorageMode), nil
}

type SoftwareStatementVerificationMethod string

const (
	SoftwareStatementVerificationMethodManual  SoftwareStatementVerificationMethod = "manual"
	SoftwareStatementVerificationMethodJwksUri SoftwareStatementVerificationMethod = "jwks_uri"
)

func (e *SoftwareStatementVerificationMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SoftwareStatementVerificationMethod(s)
	case string:
		*e = SoftwareStatementVerificationMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for SoftwareStatementVerificationMethod: %T", src)
	}
	return nil
}

type NullSoftwareStatementVerificationMethod struct {
	SoftwareStatementVerificationMethod SoftwareStatementVerificationMethod
	Valid                               bool // Valid is true if SoftwareStatementVerificationMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSoftwareStatementVerificationMethod) Scan(value interface{}) error {
	if value == nil {
		ns.SoftwareStatementVerificationMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SoftwareStatementVerificationMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSoftwareStatementVerificationMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SoftwareStatementVerificationMethod), nil
}

type TokenCryptoSuite string

const (
	TokenCryptoSuiteES256 TokenCryptoSuite = "ES256"
	TokenCryptoSuiteEdDSA TokenCryptoSuite = "EdDSA"
)

func (e *TokenCryptoSuite) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TokenCryptoSuite(s)
	case string:
		*e = TokenCryptoSuite(s)
	default:
		return fmt.Errorf("unsupported scan type for TokenCryptoSuite: %T", src)
	}
	return nil
}

type NullTokenCryptoSuite struct {
	TokenCryptoSuite TokenCryptoSuite
	Valid            bool // Valid is true if TokenCryptoSuite is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTokenCryptoSuite) Scan(value interface{}) error {
	if value == nil {
		ns.TokenCryptoSuite, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TokenCryptoSuite.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTokenCryptoSuite) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TokenCryptoSuite), nil
}

type TokenKeyType string

const (
	TokenKeyTypeAccess            TokenKeyType = "access"
	TokenKeyTypeRefresh           TokenKeyType = "refresh"
	TokenKeyTypeIDToken           TokenKeyType = "id_token"
	TokenKeyTypeClientCredentials TokenKeyType = "client_credentials"
	TokenKeyTypeEmailVerification TokenKeyType = "email_verification"
	TokenKeyTypePasswordReset     TokenKeyType = "password_reset"
	TokenKeyType2faAuthentication TokenKeyType = "2fa_authentication"
)

func (e *TokenKeyType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TokenKeyType(s)
	case string:
		*e = TokenKeyType(s)
	default:
		return fmt.Errorf("unsupported scan type for TokenKeyType: %T", src)
	}
	return nil
}

type NullTokenKeyType struct {
	TokenKeyType TokenKeyType
	Valid        bool // Valid is true if TokenKeyType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTokenKeyType) Scan(value interface{}) error {
	if value == nil {
		ns.TokenKeyType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TokenKeyType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTokenKeyType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TokenKeyType), nil
}

type TokenKeyUsage string

const (
	TokenKeyUsageGlobal  TokenKeyUsage = "global"
	TokenKeyUsageAccount TokenKeyUsage = "account"
)

func (e *TokenKeyUsage) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TokenKeyUsage(s)
	case string:
		*e = TokenKeyUsage(s)
	default:
		return fmt.Errorf("unsupported scan type for TokenKeyUsage: %T", src)
	}
	return nil
}

type NullTokenKeyUsage struct {
	TokenKeyUsage TokenKeyUsage
	Valid         bool // Valid is true if TokenKeyUsage is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTokenKeyUsage) Scan(value interface{}) error {
	if value == nil {
		ns.TokenKeyUsage, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TokenKeyUsage.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTokenKeyUsage) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TokenKeyUsage), nil
}

type TokenOwner string

const (
	TokenOwnerUser    TokenOwner = "user"
	TokenOwnerAccount TokenOwner = "account"
)

func (e *TokenOwner) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TokenOwner(s)
	case string:
		*e = TokenOwner(s)
	default:
		return fmt.Errorf("unsupported scan type for TokenOwner: %T", src)
	}
	return nil
}

type NullTokenOwner struct {
	TokenOwner TokenOwner
	Valid      bool // Valid is true if TokenOwner is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTokenOwner) Scan(value interface{}) error {
	if value == nil {
		ns.TokenOwner, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TokenOwner.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTokenOwner) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TokenOwner), nil
}

type TotpUsage string

const (
	TotpUsageAccount TotpUsage = "account"
	TotpUsageUser    TotpUsage = "user"
)

func (e *TotpUsage) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TotpUsage(s)
	case string:
		*e = TotpUsage(s)
	default:
		return fmt.Errorf("unsupported scan type for TotpUsage: %T", src)
	}
	return nil
}

type NullTotpUsage struct {
	TotpUsage TotpUsage
	Valid     bool // Valid is true if TotpUsage is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTotpUsage) Scan(value interface{}) error {
	if value == nil {
		ns.TotpUsage, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TotpUsage.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTotpUsage) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TotpUsage), nil
}

type Transport string

const (
	TransportHttp           Transport = "http"
	TransportHttps          Transport = "https"
	TransportStdio          Transport = "stdio"
	TransportStreamableHttp Transport = "streamable_http"
)

func (e *Transport) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Transport(s)
	case string:
		*e = Transport(s)
	default:
		return fmt.Errorf("unsupported scan type for Transport: %T", src)
	}
	return nil
}

type NullTransport struct {
	Transport Transport
	Valid     bool // Valid is true if Transport is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTransport) Scan(value interface{}) error {
	if value == nil {
		ns.Transport, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Transport.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTransport) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Transport), nil
}

type TwoFactorType string

const (
	TwoFactorTypeNone  TwoFactorType = "none"
	TwoFactorTypeTotp  TwoFactorType = "totp"
	TwoFactorTypeEmail TwoFactorType = "email"
)

func (e *TwoFactorType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TwoFactorType(s)
	case string:
		*e = TwoFactorType(s)
	default:
		return fmt.Errorf("unsupported scan type for TwoFactorType: %T", src)
	}
	return nil
}

type NullTwoFactorType struct {
	TwoFactorType TwoFactorType
	Valid         bool // Valid is true if TwoFactorType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTwoFactorType) Scan(value interface{}) error {
	if value == nil {
		ns.TwoFactorType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TwoFactorType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTwoFactorType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TwoFactorType), nil
}

type Account struct {
	ID            int32
	PublicID      uuid.UUID
	GivenName     string
	FamilyName    string
	Username      string
	Email         string
	Organization  pgtype.Text
	Password      pgtype.Text
	Version       int32
	EmailVerified bool
	IsActive      bool
	TwoFactorType TwoFactorType
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

type AccountAuthProvider struct {
	ID              int32
	Email           string
	Provider        AuthProvider
	AccountPublicID uuid.UUID
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

type AccountCredential struct {
	ID                      int32
	AccountID               int32
	AccountPublicID         uuid.UUID
	ClientID                string
	Name                    string
	Domain                  string
	CredentialsType         AccountCredentialsType
	Scopes                  []AccountCredentialsScope
	TokenEndpointAuthMethod AuthMethod
	GrantTypes              []GrantType
	Version                 int32
	Transport               Transport
	CreationMethod          CreationMethod
	ClientUri               string
	RedirectUris            []string
	LogoUri                 pgtype.Text
	PolicyUri               pgtype.Text
	TosUri                  pgtype.Text
	SoftwareID              string
	SoftwareVersion         pgtype.Text
	Contacts                []string
	CreatedAt               time.Time
	UpdatedAt               time.Time
}

type AccountCredentialsKey struct {
	AccountID            int32
	CredentialsKeyID     int32
	AccountCredentialsID int32
	AccountPublicID      uuid.UUID
	JwkKid               string
	CreatedAt            time.Time
}

type AccountCredentialsSecret struct {
	AccountID            int32
	CredentialsSecretID  int32
	AccountCredentialsID int32
	AccountPublicID      uuid.UUID
	SecretID             string
	CreatedAt            time.Time
}

type AccountDataEncryptionKey struct {
	AccountID           int32
	DataEncryptionKeyID int32
	CreatedAt           time.Time
}

type AccountDynamicRegistrationConfig struct {
	ID                                       int32
	AccountID                                int32
	AccountPublicID                          uuid.UUID
	AccountCredentialsTypes                  []AccountCredentialsType
	WhitelistedDomains                       []string
	RequireSoftwareStatementCredentialTypes  []AccountCredentialsType
	SoftwareStatementVerificationMethods     []SoftwareStatementVerificationMethod
	RequireInitialAccessTokenCredentialTypes []AccountCredentialsType
	InitialAccessTokenGenerationMethods      []InitialAccessTokenGenerationMethod
	CreatedAt                                time.Time
	UpdatedAt                                time.Time
}

type AccountDynamicRegistrationDomain struct {
	ID                 int32
	AccountID          int32
	AccountPublicID    uuid.UUID
	Domain             string
	VerifiedAt         pgtype.Timestamptz
	VerificationMethod DomainVerificationMethod
	CreatedAt          time.Time
	UpdatedAt          time.Time
}

type AccountDynamicRegistrationDomainCode struct {
	ID                                 int32
	AccountID                          int32
	AccountDynamicRegistrationDomainID int32
	VerificationHost                   string
	VerificationCode                   string
	HmacSecretID                       string
	VerificationPrefix                 string
	ExpiresAt                          time.Time
	CreatedAt                          time.Time
	UpdatedAt                          time.Time
}

type AccountHmacSecret struct {
	ID        int32
	AccountID int32
	SecretID  string
	Secret    string
	DekKid    string
	IsRevoked bool
	ExpiresAt time.Time
	CreatedAt time.Time
}

type AccountKeyEncryptionKey struct {
	AccountID          int32
	KeyEncryptionKeyID int32
	CreatedAt          time.Time
}

type AccountTokenSigningKey struct {
	AccountID         int32
	TokenSigningKeyID int32
	CreatedAt         time.Time
}

type AccountTotp struct {
	AccountID int32
	TotpID    int32
	CreatedAt time.Time
}

type App struct {
	ID                      int32
	AccountID               int32
	AccountPublicID         uuid.UUID
	AppType                 AppType
	Name                    string
	ClientID                string
	Version                 int32
	CreationMethod          CreationMethod
	ClientUri               string
	LogoUri                 pgtype.Text
	TosUri                  pgtype.Text
	PolicyUri               pgtype.Text
	SoftwareID              string
	SoftwareVersion         pgtype.Text
	Contacts                []string
	TokenEndpointAuthMethod AuthMethod
	Scopes                  []Scopes
	CustomScopes            []string
	GrantTypes              []GrantType
	Domain                  string
	Transport               Transport
	AllowUserRegistration   bool
	AuthProviders           []AuthProvider
	UsernameColumn          AppUsernameColumn
	DefaultScopes           []Scopes
	DefaultCustomScopes     []string
	RedirectUris            []string
	ResponseTypes           []ResponseType
	IDTokenTtl              int32
	TokenTtl                int32
	RefreshTokenTtl         int32
	CreatedAt               time.Time
	UpdatedAt               time.Time
}

type AppDesign struct {
	ID          int32
	AccountID   int32
	AppID       int32
	LightColors []byte
	DarkColors  []byte
	LogoUrl     pgtype.Text
	FaviconUrl  pgtype.Text
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type AppDynamicRegistrationConfig struct {
	ID                                   int32
	AccountID                            int32
	AllowedAppTypes                      []AppType
	WhitelistedDomains                   []string
	DefaultAllowUserRegistration         bool
	DefaultAuthProviders                 []AuthProvider
	DefaultUsernameColumn                AppUsernameColumn
	DefaultAllowedScopes                 []Scopes
	DefaultScopes                        []Scopes
	RequireSoftwareStatementAppTypes     []AppType
	SoftwareStatementVerificationMethods []SoftwareStatementVerificationMethod
	RequireInitialAccessTokenAppTypes    []AppType
	InitialAccessTokenGenerationMethods  []InitialAccessTokenGenerationMethod
	InitialAccessTokenTtl                int32
	InitialAccessTokenMaxUses            int32
	AllowedGrantTypes                    []GrantType
	AllowedResponseTypes                 []ResponseType
	AllowedTokenEndpointAuthMethods      []AuthMethod
	MaxRedirectUris                      int32
	CreatedAt                            time.Time
	UpdatedAt                            time.Time
}

type AppKey struct {
	AppID            int32
	CredentialsKeyID int32
	AccountID        int32
	CreatedAt        time.Time
}

type AppProfile struct {
	AppID       int32
	UserID      int32
	AccountID   int32
	ProfileType AppProfileType
	CreatedAt   time.Time
}

type AppRelatedApp struct {
	AccountID    int32
	AppID        int32
	RelatedAppID int32
	CreatedAt    time.Time
	UpdatedAt    time.Time
}

type AppSecret struct {
	AppID               int32
	CredentialsSecretID int32
	AccountID           int32
	CreatedAt           time.Time
}

type AppServiceConfig struct {
	ID             int32
	AccountID      int32
	AppID          int32
	UserAuthMethod AuthMethod
	UserGrantTypes []GrantType
	AllowedDomains []string
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

type CredentialsKey struct {
	ID          int32
	PublicKid   string
	PublicKey   []byte
	CryptoSuite TokenCryptoSuite
	IsRevoked   bool
	Usage       CredentialsUsage
	AccountID   int32
	ExpiresAt   time.Time
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type CredentialsSecret struct {
	ID           int32
	SecretID     string
	ClientSecret string
	StorageMode  SecretStorageMode
	DekKid       pgtype.Text
	IsRevoked    bool
	Usage        CredentialsUsage
	AccountID    int32
	ExpiresAt    time.Time
	CreatedAt    time.Time
	UpdatedAt    time.Time
}

type DataEncryptionKey struct {
	ID        int32
	Kid       string
	Dek       string
	KekKid    uuid.UUID
	Usage     DekUsage
	IsRevoked bool
	ExpiresAt time.Time
	CreatedAt time.Time
	UpdatedAt time.Time
}

type KeyEncryptionKey struct {
	ID             int32
	Kid            uuid.UUID
	Usage          KekUsage
	Version        int32
	RotatedAt      time.Time
	NextRotationAt time.Time
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

type OidcConfig struct {
	ID              int32
	AccountID       int32
	ClaimsSupported []Claims
	ScopesSupported []Scopes
	CustomClaims    []string
	CustomScopes    []string
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

type RevokedToken struct {
	ID            int32
	TokenID       uuid.UUID
	AccountID     int32
	Owner         TokenOwner
	OwnerPublicID uuid.UUID
	IssuedAt      time.Time
	ExpiresAt     time.Time
	CreatedAt     time.Time
}

type TokenSigningKey struct {
	ID            int32
	Kid           string
	KeyType       TokenKeyType
	PublicKey     []byte
	PrivateKey    string
	DekKid        string
	CryptoSuite   TokenCryptoSuite
	ExpiresAt     time.Time
	Usage         TokenKeyUsage
	IsDistributed bool
	IsRevoked     bool
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

type Totp struct {
	ID            int32
	DekKid        string
	Url           string
	Secret        string
	RecoveryCodes []byte
	Usage         TotpUsage
	AccountID     int32
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

type User struct {
	ID            int32
	PublicID      uuid.UUID
	AccountID     int32
	Email         string
	Username      string
	Password      pgtype.Text
	Version       int32
	EmailVerified bool
	IsActive      bool
	TwoFactorType TwoFactorType
	UserData      []byte
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

type UserAuthProvider struct {
	ID        int32
	UserID    int32
	AccountID int32
	Provider  AuthProvider
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserCredential struct {
	ID          int32
	UserID      int32
	AccountID   int32
	AppID       int32
	ClientID    string
	AuthMethods []AuthMethod
	Issuers     []string
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type UserCredentialsKey struct {
	UserID           int32
	CredentialsKeyID int32
	UserCredentialID int32
	AccountID        int32
	UserPublicID     uuid.UUID
	CreatedAt        time.Time
}

type UserCredentialsSecret struct {
	UserID              int32
	CredentialsSecretID int32
	UserCredentialID    int32
	AccountID           int32
	UserPublicID        uuid.UUID
	CreatedAt           time.Time
}

type UserDataEncryptionKey struct {
	UserID              int32
	DataEncryptionKeyID int32
	AccountID           int32
	CreatedAt           time.Time
}

type UserTotp struct {
	UserID    int32
	TotpID    int32
	AccountID int32
	CreatedAt time.Time
}
