// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: account_credential_secrets.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const countAccountCredentialSecretsByAccountCredentialID = `-- name: CountAccountCredentialSecretsByAccountCredentialID :one
SELECT COUNT(*) FROM "credentials_secrets" "csr"
LEFT JOIN "account_credentials_secrets" "acs" ON "acs"."credentials_secret_id" = "csr"."id"
WHERE "acs"."account_credentials_id" = $1
LIMIT 1
`

func (q *Queries) CountAccountCredentialSecretsByAccountCredentialID(ctx context.Context, accountCredentialsID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countAccountCredentialSecretsByAccountCredentialID, accountCredentialsID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAccountCredentialSecret = `-- name: CreateAccountCredentialSecret :exec

INSERT INTO "account_credentials_secrets" (
    "account_credentials_id",
    "credentials_secret_id",
    "account_id",
    "account_public_id",
    "secret_id"
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
`

type CreateAccountCredentialSecretParams struct {
	AccountCredentialsID int32
	CredentialsSecretID  int32
	AccountID            int32
	AccountPublicID      uuid.UUID
	SecretID             string
}

// Copyright (c) 2025 Afonso Barracha
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
func (q *Queries) CreateAccountCredentialSecret(ctx context.Context, arg CreateAccountCredentialSecretParams) error {
	_, err := q.db.Exec(ctx, createAccountCredentialSecret,
		arg.AccountCredentialsID,
		arg.CredentialsSecretID,
		arg.AccountID,
		arg.AccountPublicID,
		arg.SecretID,
	)
	return err
}

const findAccountCredentialSecretByAccountCredentialIDAndCredentialsSecretID = `-- name: FindAccountCredentialSecretByAccountCredentialIDAndCredentialsSecretID :one
SELECT csr.id, csr.secret_id, csr.client_secret, csr.storage_mode, csr.dek_kid, csr.is_revoked, csr.usage, csr.account_id, csr.expires_at, csr.created_at, csr.updated_at FROM "credentials_secrets" "csr"
LEFT JOIN "account_credentials_secrets" "acs" ON "acs"."credentials_secret_id" = "csr"."id"
WHERE 
    "acs"."account_credentials_id" = $1 AND 
    "csr"."secret_id" = $2
LIMIT 1
`

type FindAccountCredentialSecretByAccountCredentialIDAndCredentialsSecretIDParams struct {
	AccountCredentialsID int32
	SecretID             string
}

func (q *Queries) FindAccountCredentialSecretByAccountCredentialIDAndCredentialsSecretID(ctx context.Context, arg FindAccountCredentialSecretByAccountCredentialIDAndCredentialsSecretIDParams) (CredentialsSecret, error) {
	row := q.db.QueryRow(ctx, findAccountCredentialSecretByAccountCredentialIDAndCredentialsSecretID, arg.AccountCredentialsID, arg.SecretID)
	var i CredentialsSecret
	err := row.Scan(
		&i.ID,
		&i.SecretID,
		&i.ClientSecret,
		&i.StorageMode,
		&i.DekKid,
		&i.IsRevoked,
		&i.Usage,
		&i.AccountID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findAccountCredentialsSecretAccountByAccountCredentialIDAndSecretID = `-- name: FindAccountCredentialsSecretAccountByAccountCredentialIDAndSecretID :one
SELECT a.id, a.public_id, a.given_name, a.family_name, a.username, a.email, a.organization, a.password, a.version, a.email_verified, a.is_active, a.two_factor_type, a.created_at, a.updated_at FROM "accounts" AS "a"
LEFT JOIN "account_credentials_secrets" AS "acs" ON "acs"."account_id" = "a"."id"
WHERE
    "acs"."account_credentials_id" = $1 AND
    "acs"."secret_id" = $2
LIMIT 1
`

type FindAccountCredentialsSecretAccountByAccountCredentialIDAndSecretIDParams struct {
	AccountCredentialsID int32
	SecretID             string
}

func (q *Queries) FindAccountCredentialsSecretAccountByAccountCredentialIDAndSecretID(ctx context.Context, arg FindAccountCredentialsSecretAccountByAccountCredentialIDAndSecretIDParams) (Account, error) {
	row := q.db.QueryRow(ctx, findAccountCredentialsSecretAccountByAccountCredentialIDAndSecretID, arg.AccountCredentialsID, arg.SecretID)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.GivenName,
		&i.FamilyName,
		&i.Username,
		&i.Email,
		&i.Organization,
		&i.Password,
		&i.Version,
		&i.EmailVerified,
		&i.IsActive,
		&i.TwoFactorType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findCurrentAccountCredentialSecretByAccountCredentialID = `-- name: FindCurrentAccountCredentialSecretByAccountCredentialID :one
SELECT csr.id, csr.secret_id, csr.client_secret, csr.storage_mode, csr.dek_kid, csr.is_revoked, csr.usage, csr.account_id, csr.expires_at, csr.created_at, csr.updated_at FROM "credentials_secrets" "csr"
LEFT JOIN "account_credentials_secrets" "acs" ON "acs"."credentials_secret_id" = "csr"."id"
WHERE 
    "acs"."account_credentials_id" = $1 AND 
    "csr"."is_revoked" = false AND 
    "csr"."expires_at" > now()
LIMIT 1
`

func (q *Queries) FindCurrentAccountCredentialSecretByAccountCredentialID(ctx context.Context, accountCredentialsID int32) (CredentialsSecret, error) {
	row := q.db.QueryRow(ctx, findCurrentAccountCredentialSecretByAccountCredentialID, accountCredentialsID)
	var i CredentialsSecret
	err := row.Scan(
		&i.ID,
		&i.SecretID,
		&i.ClientSecret,
		&i.StorageMode,
		&i.DekKid,
		&i.IsRevoked,
		&i.Usage,
		&i.AccountID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findPaginatedAccountCredentialSecretsByAccountCredentialID = `-- name: FindPaginatedAccountCredentialSecretsByAccountCredentialID :many
SELECT csr.id, csr.secret_id, csr.client_secret, csr.storage_mode, csr.dek_kid, csr.is_revoked, csr.usage, csr.account_id, csr.expires_at, csr.created_at, csr.updated_at FROM "credentials_secrets" "csr"
LEFT JOIN "account_credentials_secrets" "acs" ON "acs"."credentials_secret_id" = "csr"."id"
WHERE "acs"."account_credentials_id" = $1
ORDER BY "csr"."expires_at" DESC
OFFSET $2 LIMIT $3
`

type FindPaginatedAccountCredentialSecretsByAccountCredentialIDParams struct {
	AccountCredentialsID int32
	Offset               int32
	Limit                int32
}

func (q *Queries) FindPaginatedAccountCredentialSecretsByAccountCredentialID(ctx context.Context, arg FindPaginatedAccountCredentialSecretsByAccountCredentialIDParams) ([]CredentialsSecret, error) {
	rows, err := q.db.Query(ctx, findPaginatedAccountCredentialSecretsByAccountCredentialID, arg.AccountCredentialsID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CredentialsSecret{}
	for rows.Next() {
		var i CredentialsSecret
		if err := rows.Scan(
			&i.ID,
			&i.SecretID,
			&i.ClientSecret,
			&i.StorageMode,
			&i.DekKid,
			&i.IsRevoked,
			&i.Usage,
			&i.AccountID,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findValidAccountCredentialSecretByAccountCredentialIDAndCredentialsSecretID = `-- name: FindValidAccountCredentialSecretByAccountCredentialIDAndCredentialsSecretID :one
SELECT csr.id, csr.secret_id, csr.client_secret, csr.storage_mode, csr.dek_kid, csr.is_revoked, csr.usage, csr.account_id, csr.expires_at, csr.created_at, csr.updated_at FROM "credentials_secrets" "csr"
LEFT JOIN "account_credentials_secrets" "acs" ON "acs"."credentials_secret_id" = "csr"."id"
WHERE
    "acs"."account_credentials_id" = $1 AND
    "csr"."secret_id" = $2 AND
    "csr"."is_revoked" = false AND
    "csr"."expires_at" > now()
LIMIT 1
`

type FindValidAccountCredentialSecretByAccountCredentialIDAndCredentialsSecretIDParams struct {
	AccountCredentialsID int32
	SecretID             string
}

func (q *Queries) FindValidAccountCredentialSecretByAccountCredentialIDAndCredentialsSecretID(ctx context.Context, arg FindValidAccountCredentialSecretByAccountCredentialIDAndCredentialsSecretIDParams) (CredentialsSecret, error) {
	row := q.db.QueryRow(ctx, findValidAccountCredentialSecretByAccountCredentialIDAndCredentialsSecretID, arg.AccountCredentialsID, arg.SecretID)
	var i CredentialsSecret
	err := row.Scan(
		&i.ID,
		&i.SecretID,
		&i.ClientSecret,
		&i.StorageMode,
		&i.DekKid,
		&i.IsRevoked,
		&i.Usage,
		&i.AccountID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const revokeAccountCredentialSecret = `-- name: RevokeAccountCredentialSecret :exec
UPDATE "credentials_secrets" SET
    "is_revoked" = true
WHERE "id" = $1
`

func (q *Queries) RevokeAccountCredentialSecret(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, revokeAccountCredentialSecret, id)
	return err
}
